"""
Library of common functions
"""

import base64
import copy
import json
import re
import shlex
import subprocess

def exec(command: str | list, check: bool = True) -> str:
    """
    Execute a command and returns stdout and stderr as a UTF-8 string. If you want output as binary, don't use this function as you'll
    want more fine-grained control over stdout/stderr.    

    Examples:
        output = exec("kubectl get ns")
        output = exec(["kubectl", "get", "ns"])
        output = exec(["kubectl", "get", "nonexistantnamespace"])  # Raises CalledProcessError
        output = exec(["kubectl", "get", "nonexistantnamespace"], check = False) # Does not raise an error

    Args:
        command: string or list. The command to run. If a string, it is parsed according to shell rules (to handle things like 'cmd "quoted argument"')
        check: boolean, defaults to True. If True and the command errors, it will raise a CalledProcessError. Otherwise, the return value is unchecked.

    Returns
        String holding output of command
    """
    if not isinstance(command, list):
        command = shlex.split(command)
    process = subprocess.run(command, check = check, text = True, encoding = "utf-8", stdout = subprocess.PIPE, stderr = subprocess.STDOUT)
    return process.stdout

def format_url(url: str) -> str:
    """
    Given a URL, ensures it has a beginning protocol and an ending slash.
    """
    if not url.startswith("http"):
        url = "https://" + url
    if not url.endswith("/") and not "." in url:
        url = url + "/"
    return url

def override_nested_dict(data: dict, overrides: [str]) -> dict:
    """
    Given a dictionary, override it with the overrides in the format of "<nested key>=<value>", where "nested key" is nested with .s.

    Examples:
        override_nested_dict({"a": "apple", "b": "banana"}, ["a=alligator"]) => {"a": "alligator", "b": "banana"}
        override_nested_dict({"data": {"key1": "value1" }}, ["data.key1=value2"]) => {"data": {"key1": "value2"}}

    Args:
        data: Dictionary
        overrides: List of strings in the format of "<nested key>=<value>")

    Returns:
        Resulting dictionary with overrides applied
    """
    result = copy.deepcopy(data)
    for override in overrides:
        subresult = result
        key, value = override.split("=", 2)
        subkeys = key.split(".")
        for subkey in subkeys[0:-1]:
            if not subresult.has_key(subkey):
                subresult["subkey"] = {}
            subresult = subresult[subkey]
        subresult[subkeys[-1]] = value
    return result

def to_json_dict(data: str) -> dict:
    """
    Given a string representation of a JSON object, returns it as a dictionary. Entirely a convenience method to allow changing of parsing or library if needed.
    This is the opposite of to_json_str.

    Args:
        data: String containing JSON data

    Returns:
        Dictionary representation of JSON data
    """
    return json.loads(data)

def to_json_str(data: dict) -> str:
    """
    Given a dictionary, returns the JSON string representation. Entirely a convenience method to allow changing of parsing or library if needed.
    This is the opposite of to_json_dict.

    Args:
        data: Dictionary

    Returns:
        JSON string representation
    """
    return json.dumps(data, sort_keys = True, indent = 4)

def b64decode(text: str) -> str:
    """
    Given a base64 encoded string, returns the decoded version. Automatically removes whitespace from input string.

    Args:
        text: Base64 encoded string. Whitespace will be removed.

    Returns:
        Decoded output as UTF-8 string
    """
    return base64.b64decode(re.sub(r"\s", "", text)).decode("utf-8")
