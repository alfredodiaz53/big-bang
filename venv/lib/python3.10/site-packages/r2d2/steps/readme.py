import importlib.resources
import os
from pathlib import Path

import keepachangelog
import requests
from jinja2 import Template
from ruamel.yaml import YAML
from tabulate import tabulate


def get_pkg_data(pkg):
    cache_dir = Path.home().joinpath(f".r2d2/cache/{pkg['name']}_{pkg['tag']}")

    chart_path = cache_dir.joinpath("Chart.yaml")
    changelog_path = cache_dir.joinpath("CHANGELOG.md")
    is_cached = Path.exists(chart_path) and Path.exists(changelog_path)

    if is_cached:
        return {
            "chart": YAML().load(open(chart_path, "r")),
            "changelog": keepachangelog.to_dict(changelog_path),
        }
    else:
        os.makedirs(cache_dir, exist_ok=True)

    # get the chart
    chart_url = f"{pkg['repo'].replace('.git','')}/-/raw/{pkg['tag']}/chart/Chart.yaml"
    chart_res = requests.get(chart_url)
    if chart_res.status_code != 200:
        print(f"\n ERROR: {pkg['name']} {pkg['tag']} Chart not found in repo1.dso.mil")
        return
    chart = chart_res.text
    chart_path.open("w").write(chart)

    # get the changelog
    changelog_url = f"{pkg['repo'].replace('.git','')}/-/raw/{pkg['tag']}/CHANGELOG.md"
    changelog_res = requests.get(changelog_url)
    if changelog_res.status_code != 200:
        print(
            f"\n ERROR: {pkg['name']} {pkg['tag']} CHANGELOG not found in repo1.dso.mil"
        )
        return
    changelog = changelog_res.text
    # some fuckery to make our changelogs actually KAC compliant
    changelog = changelog.replace("\n---", "")
    clean_changelog = []
    for line in changelog.split("\n"):
        if line.startswith("## ") and len(line.split("-")) <= 3:
            line = line.strip() + " - 1970-01-01"
        if line.startswith("#") or line.startswith("-"):
            clean_changelog.append(line)

    changelog = "\n\n".join(clean_changelog)

    changelog_path.open("w").write(changelog)

    return {
        "chart": YAML().load(open(chart_path, "r")),
        "changelog": keepachangelog.to_dict(changelog_path),
    }


def format_app_versions(app_versions):
    app_versions = list(
        filter(
            lambda l: len(l) > 0,
            ([line.replace("- ", "") for line in app_versions.split("\n")]),
        )
    )
    remove_v_prefix = lambda x: x[1:] if x.startswith("v") else x
    if len(app_versions) > 1:
        for idx, app_version in enumerate(app_versions):
            name, version = [item.strip() for item in app_version.split(":")]
            version = remove_v_prefix(version)
            app_versions[idx] = f"{name} `{version}`"
    else:
        _, version = [item.strip() for item in app_versions[0].split(":")]
        version = remove_v_prefix(version)
        app_versions[0] = f"`{version}`"

    return app_versions


class R2D2Step:
    step = "Build release notes"

    def __init__(self, repo, repo1, console, config):
        self.repo = repo
        self.repo1 = repo1
        self.console = console
        self.config = config

    def run(self):
        self.console.info(f":scroll: Building release notes")
        self.console.info(f"From BB version: {self.repo1.last_release_tag}")
        self.console.info(f"To BB version: {self.repo1.next_release_tag}")
        self.console.info(f"Release Branch: {self.repo1.release_branch}")

        self.console.spinner.start(f"Checking out {self.repo1.release_branch}")
        self.repo.checkout(self.repo1.release_branch)
        self.console.spinner.succeed(
            self.console.term.green(f"Switched to branch {self.repo1.release_branch}")
        )

        self.console.success(
            f"Getting packages from branch {self.repo1.release_branch}"
        )
        pkgs = self.repo.get_pkgs()

        self.console.spinner.start(f"Checking out {str(self.repo1.last_release_tag)}")
        self.repo.checkout(str(self.repo1.last_release_tag))
        self.console.spinner.succeed(
            self.console.term.green(
                f"Switched to branch {str(self.repo1.last_release_tag)}"
            )
        )

        self.console.success(f"Getting packages from tag {self.repo1.last_release_tag}")
        pkgs_last_release = self.repo.get_pkgs()

        self.repo.checkout(self.repo1.release_branch)

        self.build_release_notes(
            current_pkgs=pkgs,
            previous_pkgs=pkgs_last_release,
        )

    def build_release_notes(self, current_pkgs, previous_pkgs):
        notes_path = Path.cwd().joinpath(
            f"release-notes-{self.repo1.next_release_tag.major}-{self.repo1.next_release_tag.minor}-{self.repo1.next_release_tag.patch}.md"
        )

        resources_path = importlib.resources.files(__package__)

        template_path = Path.joinpath(resources_path, "../templates/release-notes.md")

        md_template = Template(
            template_path.open().read(),
            trim_blocks=True,
            lstrip_blocks=True,
        )

        if Path.exists(notes_path):
            os.remove(notes_path)

        notes = open(notes_path, "w")

        packages_table = []

        upgraded_packages = []

        changelog_diffs = {}

        for name, pkg in current_pkgs.items():
            is_new = False
            try:
                previous = (previous_pkgs[name] is not None)
            except:
                is_new = True

            if not is_new:
                haschanged = pkg["tag"] != previous_pkgs[name]["tag"]
                if not haschanged:
                    self.console.info(f"{name} has not changed")
                    # dont include this package in the release notes
                    # continue
                else:
                    self.console.warning(
                        f"{name} has changed from {previous_pkgs[name]['tag']} to {pkg['tag']}"
                    )
            else:
                self.console.warning(f"{name} is new")
                haschanged = False

            self.console.spinner.start(f"Building {name}'s package changelog")

            meta = get_pkg_data(pkg)
            if meta is None:
                self.console.spinner.error(
                    self.console.term.red(
                        f"{name}@{pkg['tag']} Chart not found in self.repo1.dso.mil"
                    )
                )
                continue

            chart, changelog = meta["chart"], meta["changelog"]

            app_versions = "N/A"
            try:
                app_versions = format_app_versions(
                    chart["annotations"]["bigbang.dev/applicationVersions"]
                )
            except:
                self.console.warning(f"{name} does not have an app version.")

            # taken from r2-d2.yaml
            if pkg["name"] in self.config["package_overrides"]:
                pkg["name"] = self.config["package_overrides"][pkg["name"]]["name"]
                pkg["title"] = self.config["package_overrides"][pkg["name"]]["title"]

            url = pkg["repo"].replace(".git", "")
            if haschanged and not is_new:
                upgraded_packages.append(
                    {
                        **pkg,
                        "url": url,
                        "last_tag": previous_pkgs[name]["tag"],
                    }
                )

            row_cols = [
                f"[{pkg['title']}]({url})",
                pkg["type"],
                " ".join(app_versions),
                f"`{pkg['tag']}`",
            ]

            if is_new:
                label = "New"
            elif haschanged:
                label = "Updated"
            else:
                label = ""

            if len(label) > 0:
                row_cols[0] = (
                    # f"![{label}: {self.repo1.next_release_tag}](https://img.shields.io/badge/{label}-{self.repo1.next_release_tag}-informational?style=flat-square) "
                    f"![{label}](https://img.shields.io/badge/{label}-informational?style=flat-square) "
                    + row_cols[0]
                )

            # taken from r2-d2.yaml
            pkg_is_beta = name in self.config["beta_list"]
            if pkg_is_beta:
                row_cols[
                    0
                ] += " ![BETA](https://img.shields.io/badge/BETA-purple?style=flat-square)"

            packages_table.append(row_cols)

            # changelog diffs:
            if changelog == None:
                self.console.spinner.fail(
                    self.console.term.red(
                        f"{name}@{pkg['tag']} Failed to parse CHANGELOG, manual intervention required."
                    )
                )
                continue
            elif haschanged == True:
                changelog_diff = {}

                for k, v in changelog.items():
                    if k == previous_pkgs[name]["tag"]:
                        break
                    changelog_diff[k] = v

                dirty_diff = keepachangelog.from_dict(changelog_diff)
                dirty_diff = dirty_diff.replace(" - 1970-01-01", "")
                clean_diff = "\n".join(dirty_diff.split("\n")[6:-2])
                changelog_diffs[pkg["title"]] = clean_diff

                row_cols[3] += f" [ðŸ”—](#{pkg['title'].lower().replace(' ','-')})"

            self.console.spinner.stop()

        last_known_issues = self.repo1.get_last_known_issues()
        if isinstance(last_known_issues, Exception):
            last_known_issues = "## Known Issues\n\n> Known issues not found for previous release. Manually add any known issues or delete this section\n"

        notes.write(
            md_template.render(
                packages_table=tabulate(
                    packages_table,
                    headers=["Package", "Type", "Package Version", "BB Version"],
                    tablefmt="github",
                ),
                last_release=self.repo1.last_release_tag,
                next_release_tag=self.repo1.next_release_tag,
                mr_changes=self.repo1.get_completed_mrs(),
                changelog_diffs=changelog_diffs,
                upgraded_packages=upgraded_packages,
                known_issues=last_known_issues,
            )
        )

        notes.close()

        self.console.success("Release notes written to {}".format(notes_path))
